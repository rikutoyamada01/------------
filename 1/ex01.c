/* アルゴリズムとデータ構造B
   3I 50番 山田陸斗 提出日：2025/10/1
   #1 ポインタの復習 */

#include <stdio.h>

// 関数ポインタで管理する関数．変更の必要なし
int func(int i)
{
    return i;
}

// 設問１０：swap関数を作成する
void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int main() {
    // 通常のポインタ変数
    {
        int a;
        a = 5;
        int *p;
        p = &a;  // 同時に書くと int *p=&a;
        printf("変数aのアドレス，値をaを用いて出力\n");
        printf("&a : %p, a : %d\n", &a, a);

        printf("設問１：変数aのアドレス，値をポインタpを用いて出力\n");
        // 設問１：pが指す変数のアドレス，pが指す変数の値をpを用いて出力
        printf("p: %p, *p: %d\n", p, *p);
    }

    {
        int a[5] = {1, 2, 3, 4, 5};
        int *p1, *p2;
        p1 = &a[2];
        p2 = &a[4];
        printf("\n配列aの2番目，4番目の要素のアドレス，値をaを用いて出力\n");
        printf("&a[2] : %p, a[2] : %d\n", &a[2], a[2]);
        printf("&a[4] : %p, a[4] : %d\n", &a[4], a[4]);

        printf("設問２：配列aの2番目，4番目の要素のアドレス，値をp1, p2を用いて出力\n");
        // 設問２：
        // 配列aの2番目の要素のアドレス，値をp1を用いて出力
        printf("p1: %p, *p1: %d\n", p1, *p1);

        // 配列aの4番目の要素のアドレス，値をp2を用いて出力
        printf("p2: %p, *p2: %d\n", p2, *p2);
    }

    // 配列としてのポインタ
    {
        int a[5] = {1, 2, 3, 4, 5};
        int *p;
        p = a;  // p = &a[0]; も同じ意味
        printf("\n配列aの先頭（0番目），2番目の要素のアドレス，値をaを用いて出力\n");
        printf("&a[0] : %p, a[0] : %d\n", &a[0], a[0]);
        printf("&a[2] : %p, a[2] : %d\n", &a[2], a[2]);

        printf("設問３：配列aの先頭（0番目）のアドレス，値をpを用いて出力\n");
        // 設問３：設問３：配列aの先頭（0番目）のアドレス，値をpを用いて出力
        printf("p: %p, *p: %d\n", p, *p);

        printf("設問４：配列aの2番目の要素のアドレス，値をpを用いて出力\n");
        // 設問４：配列aの2番目の要素のアドレス，値をpを用いて出力
        printf("p+2: %p, *(p+2): %d\n", p + 2, *(p + 2));

        printf("設問５：配列aの2番目の要素のアドレス，値をpを用いて配列風の記述で出力\n");
        // 設問５：配列aの2番目の要素のアドレス，値をpを用いて配列風の記述で出力
        printf("&p[2]: %p, p[2]: %d\n", &p[2], p[2]);

        printf("設問６：配列aの2番目の要素のアドレス，値をaを用いてポインタ風の記述で出力\n");
        // 設問６：配列aの2番目の要素のアドレス，値をaを用いてポインタ風の記述で出力
        printf("&a[2]: %p, *(a+2): %d\n", &a[2], *(a + 2));

    }

    // 関数ポインタ
    {
        int func(int);  // プロトタイプ宣言
        int (*p_func)(int);
        p_func = func;
        printf("\n関数funcのアドレス : %p, func(5) : %d\n", func, func(5));

        printf("設問７：関数ポインタp_funcを用いて，関数funcのアドレスを出力，funを呼び出す\n");
        // 設問７：関数ポインタp_funcを用いて，関数funcのアドレスを出力，funを呼び出す
        printf("address(func(5)): %p, func(5): %d\n", p_func, (*p_func)(5));

    }

    // swap関数の作成
    {
        printf("\n設問８～１０：配列の要素の値を入れ替えるswap関数を作成\n");
        // 設問８：正しくプロトタイプ宣言する
        void swap(int*, int*);
        int a[2] = {5, 3};
        printf("a[0] = %d, a[1] = %d\n", a[0], a[1]);
        // 設問９：正しく swap関数を呼び出し，a[0]とa[1]の値を交換する
        swap(&a[0], &a[1]);

        // 表示して確認
        printf("swap後\n");
        printf("a[0] = %d, a[1] = %d\n", a[0], a[1]);
    }

    return 0;
}

/* 実行結果を以下に貼り付けて提出

変数aのアドレス，値をaを用いて出力
&a : 0x7ffd8ddf3b84, a : 5
設問１：変数aのアドレス，値をポインタpを用いて出力
p: 0x7ffd8ddf3b84, *p: 5

配列aの2番目，4番目の要素のアドレス，値をaを用いて出力
&a[2] : 0x7ffd8ddf3bb8, a[2] : 3
&a[4] : 0x7ffd8ddf3bc0, a[4] : 5
設問２：配列aの2番目，4番目の要素のアドレス，値をp1, p2を用いて出力
p1: 0x7ffd8ddf3bb8, *p1: 3
p2: 0x7ffd8ddf3bc0, *p2: 5

配列aの先頭（0番目），2番目の要素のアドレス，値をaを用いて出力
&a[0] : 0x7ffd8ddf3bb0, a[0] : 1
&a[2] : 0x7ffd8ddf3bb8, a[2] : 3
設問３：配列aの先頭（0番目）のアドレス，値をpを用いて出力
p: 0x7ffd8ddf3bb0, *p: 1
設問４：配列aの2番目の要素のアドレス，値をpを用いて出力
p+2: 0x7ffd8ddf3bb8, *(p+2): 3
設問５：配列aの2番目の要素のアドレス，値をpを用いて配列風の記述で出力
&p[2]: 0x7ffd8ddf3bb8, p[2]: 3
設問６：配列aの2番目の要素のアドレス，値をaを用いてポインタ風の記述で出力
&a[2]: 0x7ffd8ddf3bb8, *(a+2): 3

関数funcのアドレス : 0x60a7b56b2189, func(5) : 5
設問７：関数ポインタp_funcを用いて，関数funcのアドレスを出力，funを呼び出す
address(func(5)): 0x60a7b56b2189, func(5): 5

設問８～１０：配列の要素の値を入れ替えるswap関数を作成
a[0] = 5, a[1] = 3
swap後
a[0] = 3, a[1] = 5
*/
